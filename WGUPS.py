
# need to pack truck 2 with all truck 2 packages
# group packages that have to be delivered
# prioritize delivery_deadlines
from data import Delivery_Data
from datetime import timedelta, time, datetime
from pprint import pprint
from copy import deepcopy

class Truck:
    """
    Function
    _________
        Represents a truck carrying packages and routes to travel

    Params
    _______
        __init__(self, truckNum)
            truckNum : the number of the truck. some packages require certain truckNum

        self.max_packages = 16  :  Maximum packages the truck can hold.
        self.average_speed = 18  :  Average speed the truck. Includes delivery time.
        self.truckNum = truckNum  :  The number of the truck. Some packages require certain truckNum.
        self.packages = []  :  Package objects that the truck is currently carrying.
        self.packages_delivered = 0  :  Number of packages the truck has delivered.
        self.carried_without_going_to_hub = 0  :  Number of packages "picked up" without restocking.
        self.locations = []  :  Locations to hold viable delivery points.
        self.current_location = "HUB"  :  Holds current location of the truck or next delivery location.
        self.shortest_route = ["HUB"]  :  Holds the route path generated by the Delivery_Distribution.find_route method.
        self.time_of_next_delivered = None  :  Time when next location pacakges will be delivered.
        self.currently_delivering_to = None :  Holds next location step in route.
        self.currently_delivering = [] : Packages of next location
    """

    def __init__(self, truckNum):
        self.max_packages = 16
        self.average_speed = 18
        self.truckNum = truckNum
        self.packages = []
        self.packages_delivered = 0
        self.carried_without_going_to_hub = 0
        self.time_left_hub = None
        self.locations = []
        self.current_location = "HUB"
        self.shortest_route = ["HUB"]
        self.time_of_next_delivered = None
        self.currently_delivering_to = ""
        self.currently_delivering = []


class Package:
    """
    Function
    _________
        Represents a package. Holds package and delivery information.

    Params
    _______
        __init__(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[])

        self.packageID = packageID  :  Package ID
        self.delivery_address = delivery_address  :  Address it needs delivered to.
        self.address_Name = address_Name  :  Location name of address.
        self.delivery_deadline = delivery_deadline  :  Time package needs to be delivered by.
        self.delivery_city = delivery_city  :  City of address.
        self.delivery_zip_code = delivery_zip_code  :  Zip Code of address.
        self.weight = weight  :  Weight of the pacakge.
        self.status = status  :  Delivery Status of packages. "Delivered", "Out for delivery", "Not Delivered".
        self.truck = truck  :  Truck that is assigned to.
        self.available = available  :  Time that package is available for delivery.
        self.packaged_with = packaged_with  :  packageID's that have to be loaded at the same time.
        self.delivery_time = None  :  Time of delivery completion.

    Methods
    ________
        None
    """

    def __init__(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[]):
        self.packageID = packageID
        self.delivery_address = delivery_address
        self.address_Name = address_Name
        self.delivery_deadline = delivery_deadline
        self.delivery_city = delivery_city
        self.delivery_zip_code = delivery_zip_code
        self.weight = weight
        self.status = status
        self.truck = truck
        self.available = available
        self.packaged_with = packaged_with
        self.delivery_time = None

    def __repr__(self):
        return str({"packageID" : self.packageID,
                "delivery_address" : self.delivery_address,
                "address_Name" : self.address_Name,
                "delivery_deadline" : self.delivery_deadline,
                "delivery_city" : self.delivery_city,
                "delivery_zip_code" : self.delivery_zip_code,
                "weight" : self.weight,
                "status" : self.status,
                "truck" : self.truck,
                "available" : self.available,
                "packaged_with" : self.packaged_with,
                "delivery_time" : self.delivery_time
                })


class Delivery_Distribution:
    """
    Function
    _________
        Controls routing

    Params
    _______
        __init__(self, delivery_data, trucks=[])

        self.packages = []  :  Packages in the system.
        self.left_to_deliver = 0  :  Packages without "Delivered" status.
        self.delivery_data = delivery_data  :  Data object that holds distance information between locations.
        self.trucks = trucks  :  Array of Truck objects in the system.
        self.delivery_time = datetime(2020,5,29,8,0,0)  :  Time of day. Start 8:00
        self.end_time = self.delivery_time + timedelta(hours=9)  :  End of day.
        self.packaged_with_left = [13, 14, 15, 16, 19, 20]  : packages that have to be picked up together
        self.packaged_with_truck = 0  :  Truck that is carrying the packages_with_left packages
        self.packages_with_deadlines = []  :  packages that have deadlines earlier than end of day (self.end_time)


    Methods
    ________
        add_package(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[])
            -- adds package to self.packages

        lookup_package(self, packageID=None, delivery_address=None, address_Name=None, delivery_deadline=None, delivery_city=None, delivery_zip_code=None, weight=None, status=None)
            -- lookup package

        lookup_status(self, packageID)
            -- lookup package status givin ID

        get_packages_with_deadlines(self, package_search="Not Delivered")
            -- returns a list of package objects with deadlines other than EOD

        set_truck_routes(self)
            -- sets truck routes

        check_if_met_deadlines(self)
            -- checks if package delivery_times are made on or before package deadlines

        shuffle_for_deadlines(self, deadlines_not_met)
            -- rearrange route so deadlines are met

        adjust_delivery_times(self, truck)
            -- adjust shuffled route package delivery time

        route_is_valid(self, route, truck)
            -- checks if shuffled route is valid

        get_deadline(self, deadline_packages)
            -- get deadline to meet for group of packages

        get_truck_routes(self, truck)
            -- finds optimal route and adds for givin truck

        print_route_results(self)
            -- print package status by delivery times and final routes and distances

        end_lookups(self)
            -- user interface to look up package data and delivery details

        print_status(self)
            -- print package status by delivery times

        find_and_deliver(self, truck)
            -- establish next delivery location for passed truck

        get_truck_routes(self, truck)
            -- get possible locations, run search, add to route

        add_route(self, truck, location)
            -- adds route to truck, updates truck and package information

        find_route(self, truck, location_taken=None)
            -- find optimal route from available locations

        get_packages(self, location, truck)
            -- return valid packages for truck at location

        get_available_locations(self, truck)
            -- return available locations passed truck

        get_deadline_locations(self, deadline_packages)
            -- get address_Name(s) for deadline_packages not delivered

        get_route_distance(self, route)
            -- return distance of passed route

        route_time(self, route, truck_speed)
            -- return time it takes to complete route

    """

    def __init__(self, delivery_data, trucks=[]):
        self.packages = {"Delivered" : {}, "Not Delivered" : {}}
        self.left_to_deliver = 0
        self.delivery_data = delivery_data
        self.trucks = trucks
        self.delivery_time = datetime(2020,5,29,8,0,0)
        self.end_time = self.delivery_time + timedelta(hours=9)
        self.packaged_with_left = [13, 14, 15, 16, 19, 20]
        self.packaged_with_truck = 0
        self.packages_with_deadlines = []

    def add_package(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[]):
        """
        Initializes packages with information provided in the package data.
        Adds packages to self.packages
        """

        if available == "8:00":
            available = self.delivery_time
        else:
            hours = int(available[:available.find(":")]) - 8
            mins = int(available[available.find(":")+1:])
            available = self.delivery_time + timedelta(hours=hours, minutes=mins)

        if delivery_deadline == "EOD":
            delivery_deadline = self.delivery_time + timedelta(hours=9)

        else:
            hours = int(delivery_deadline[:delivery_deadline.find(":")]) - 8
            mins = int(delivery_deadline[delivery_deadline.find(":")+1:])
            delivery_deadline = self.delivery_time + timedelta(hours=hours, minutes=mins)

        self.packages["Not Delivered"][packageID] = Package(packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=truck,
                                                            available=available, packaged_with=packaged_with)


    def lookup_package(self, packageID=None, delivery_address=None, address_Name=None, delivery_deadline=None, delivery_city=None, delivery_zip_code=None, weight=None, status=None):
        """
        Lookup package details.
        Searches and returns package objects that align with passed search parameters.
        """

        packages = []

        if packageID in self.packages["Delivered"].keys():
            return self.packages["Delivered"][packageID]

        elif packageID in self.packages["Not Delivered"].keys():
            return self.packages["Not Delivered"][packageID]


        for package in self.packages["Delivered"].values():
            if package.delivery_address == delivery_address:
                packages.append(package)
            elif package.address_Name == address_Name:
                packages.append(package)
            elif package.delivery_deadline == delivery_deadline:
                packages.append(package)
            elif package.delivery_city == delivery_city:
                packages.append(package)
            elif package.delivery_zip_code == delivery_zip_code:
                packages.append(package)
            elif package.weight == weight:
                packages.append(package)
            elif package.status == status:
                packages.append(package)
            else:
                continue

        for package in self.packages["Not delivered"].values():
            if package.delivery_address == delivery_address:
                packages.append(package)
            elif package.address_Name == address_Name:
                packages.append(package)
            elif package.delivery_deadline == delivery_deadline:
                packages.append(package)
            elif package.delivery_city == delivery_city:
                packages.append(package)
            elif package.delivery_zip_code == delivery_zip_code:
                packages.append(package)
            elif package.weight == weight:
                packages.append(package)
            elif package.status == status:
                packages.append(package)
            else:
                continue

        return packages


    def lookup_status(self, packageID):
        """
        Returns package status for givin packageID
        """

        return self.lookup_package(packageID=packageID)[0].status


    def get_packages_with_deadlines(self, package_search="Not Delivered"):
        """
        Returns a list of package objects with delivery deadlines other than EOD
        """

        packages_with_deadlines = []
        for packageID, package in self.packages[package_search].items():
            if package.delivery_deadline != self.end_time:
                packages_with_deadlines.append(packageID)

        return packages_with_deadlines

    def set_truck_routes(self):
        """
        Increments by delivery time and calls find_and_deliver(truck) for whichever truck is available.
        When all packages are delivered. checks are run to see if all package deadlines are met
        and adjust truck routes if necessary. Finally, prints routing results by calling
        print_route_results.
        """

        self.packages_with_deadlines = self.get_packages_with_deadlines()
        self.left_to_deliver = len(self.packages["Not Delivered"])

        self.truck1 = self.trucks[0]
        self.truck2 = self.trucks[1]

        self.truck1.time_of_next_delivered = self.delivery_time
        self.truck2.time_of_next_delivered = self.delivery_time
        self.truck1.time_left_hub = self.delivery_time
        self.truck2.time_left_hub = self.delivery_time

        self.truck1.done = False
        self.truck2.done = False

        while self.delivery_time < self.end_time:

            if self.truck1.time_of_next_delivered <= self.truck2.time_of_next_delivered and not self.truck1.done:
                self.find_and_deliver(self.truck1)

            else:
                self.find_and_deliver(self.truck2)

            deadlines_not_met = self.check_if_met_deadlines()
            print(f"deadlines_not_met: {deadlines_not_met}")


            success=True
            if deadlines_not_met:
                success = self.shuffle_for_deadlines(deadlines_not_met)

            if not success:
                print("route deadlines cannot be met")


            if self.left_to_deliver == 0:
                break
            else:
                self.delivery_time = min(self.truck1.time_of_next_delivered, self.truck2.time_of_next_delivered)


        self.print_route_results()


    def check_if_met_deadlines(self):
        """
        Searches delivered packages to check if delivery deadlines have been met.
        Returns and packageIDs that have not met delivery deadlines.
        """

        deadlines_not_met = []
        for packageID, package in self.packages["Delivered"].items():
            if package.delivery_deadline < package.delivery_time:
                deadlines_not_met.append(packageID)

        return deadlines_not_met


    def shuffle_for_deadlines(self, deadlines_not_met):
        """
        Rearranges routes so that all package deadlines are met. Inserts route location into
        truck.shortest_route and runs route_is_valid check. Updates truck.shortest_route to the
        most efficient rearrangement that meets the deadlines.
        """

        deadline_package_index = -1
        truck = 0

        for id in deadlines_not_met:
            package = self.packages['Delivered'][id]

            if package.address_Name in self.truck1.shortest_route:
                deadline_package_index = self.truck1.shortest_route.index(package.address_Name)
                truck = self.truck1

            else:
                deadline_package_index = self.truck2.shortest_route.index(package.address_Name)
                truck = self.truck2


            deadline_location = truck.shortest_route[deadline_package_index]
            deadline_packages = self.get_packages(deadline_location, truck, package_search="Delivered")

            time_to_meet = self.get_deadline(deadline_packages)
            route = truck.shortest_route[:]

            route.remove(deadline_location)
            delivery_time = datetime(2020,5,29,8,0,0)

            finish_index = len(route)
            for i in range(len(route)-1):
                seg = [route[i], route[i+1]]
                delivery_time += timedelta(seconds=self.route_time(seg, truck.average_speed))

                if delivery_time >= time_to_meet:
                    finish_index = i
                    break


            distance = -1
            best_route = None
            cycles = len(route)
            while best_route == None and cycles>0:
                for i in range(1, finish_index):
                    test_route = route[:]
                    test_route.insert(i, deadline_location)
                    truck.shortest_route = test_route
                    self.adjust_delivery_times(truck)

                    if self.route_is_valid(test_route, truck):

                        test_distance = self.get_route_distance(test_route)

                        if distance == -1:
                            distance = test_distance
                            best_route =  test_route

                        elif distance > test_distance:
                            distance = test_distance
                            best_route = test_route

                if not best_route:
                    packages_with_deadlines = self.get_packages_with_deadlines(package_search="Delivered")

                    delivery_time = datetime(2020,5,29,8,0,0)
                    for i in range(1, len(route)):
                        delivery_time += timedelta(seconds=self.route_time([route[i-1], route[i]], truck.average_speed))

                        location_packages = self.get_packages(route[i], truck, package_search="Delivered")

                        for package in location_packages:
                            if package.packageID in packages_with_deadlines and package.delivery_deadline + timedelta(seconds=self.route_time([deadline_location, package.address_Name], truck.average_speed)) > delivery_time:
                                if i>1:
                                    temp = route[i-1]
                                    route[i-1] = route[i]
                                    route[i] = temp

                cycles-=1

            if not best_route:
                print("route_not_possible")
                return False

            else:
                print("route_adjusted")
                truck.current_location =  best_route[-1]
                truck.shortest_route = best_route
                self.adjust_delivery_times(truck)
                return True


    def adjust_delivery_times(self, truck):
        """
        Recalculates package delivery times for a shuffled route
        """

        delivery_time = datetime(2020,5,29,8,0,0)
        for i in range(1,len(truck.shortest_route)):
            route_seg = [truck.shortest_route[i-1], truck.shortest_route[i]]
            delivery_time += timedelta(seconds = self.route_time(route_seg, truck.average_speed))
            if truck.shortest_route[i] == "HUB":
                continue
            else:
                packages = self.get_packages(truck.shortest_route[i], truck, package_search="Delivered")
                for package in packages:
                    # print(package.address_Name, delivery_time)
                    package.delivery_time = delivery_time


    def route_is_valid(self, route, truck):
        """
        Checks if route meets all constraints (ex. deadlines met, packged_with, max_packages).
        Returns boolean of route validity.
        """

        packages_with_deadlines = self.get_packages_with_deadlines(package_search="Delivered")
        packaged_with = [13, 14, 15, 16, 19, 20]
        packagesNum = 0
        packaged_with_taken = False

        delivery_time = datetime(2020,5,29,8,0,0)
        for i in range(len(route)):
            if i != 0:
                delivery_time += timedelta(seconds=self.route_time([route[i-1], route[i]], truck.average_speed))

            if route[i] == "HUB":
                if packaged_with_taken and packaged_with:
                    return False
                packagesNum = 0
            else:
                location_packages = self.get_packages(route[i], truck, package_search="Delivered")

                for package in location_packages:
                    if package.packageID in packages_with_deadlines and package.delivery_deadline < delivery_time:
                        return  False

                    if package.packageID in packaged_with:
                        packaged_with_taken = True
                        packaged_with.remove(package.packageID)

                packagesNum += len(location_packages)

            if packagesNum > 16:
                return False

        print("route is valid")
        return True


    def get_deadline(self, deadline_packages):
        """
        Get time to meet for deadline_packages passed. Returns datetime object.
        """

        time_to_meet = datetime(2020,5,29,17,0,0)
        for package in deadline_packages:
            if self.packages["Delivered"][package.packageID].delivery_deadline < time_to_meet:
                time_to_meet = self.packages["Delivered"][package.packageID].delivery_deadline

        return time_to_meet

    def print_route_results(self):
        """
        Prints package status at delivery_times via print_status method.
        Prints each trucks final route distance, route, and number of packages.
        Prints total distance travelled for both trucks.
        Finally, calls end_lookups for user inspection of results.
        """

        self.print_status()

        print("\ntruck1")
        print(self.get_route_distance(self.truck1.shortest_route))
        print(self.truck1.shortest_route)
        print(f"truck1 packages_delivered: {self.truck1.packages_delivered}")

        print("\ntruck2")
        print(self.get_route_distance(self.truck2.shortest_route))
        print(self.truck2.shortest_route)
        print(f"truck2 packages_delivered: {self.truck2.packages_delivered}")

        print(f"\ntotal distance: {self.get_route_distance(self.truck1.shortest_route) + self.get_route_distance(self.truck2.shortest_route)}")


        self.end_lookups()


    def end_lookups(self):
        """
        User interface to lookup results of the program execution. Individual package details
        can be seen, all packages, or package statuses at a given time
        """

        print("\n")

        while True:

            # try:
            print("Check package details by packageID or see all status at specified time")
            prompt = str(input("(ex. 1 or 8:30 or all, enter q to quit): "))

            if prompt == "all":
                for packageID, package in self.packages['Delivered'].items():

                    print_package = deepcopy(package)
                    print_package.status = "Delivered"
                    print_package.delivery_time = print_package.delivery_time.strftime("%H:%M:%S")
                    print_package.delivery_deadline = print_package.delivery_deadline.strftime("%H:%M:%S")
                    print_package.available = print_package.available.strftime("%H:%M:%S")

                    print('\n')
                    print('package ID: ',  print_package.packageID)
                    print('weight: ', print_package.weight)
                    print('status: ', print_package.status)
                    print('truck: ', print_package.truck)
                    print('delivery address: ', print_package.delivery_address)
                    print('address name: ', print_package.address_Name)
                    print('city: ', print_package.delivery_city)
                    print('zip: ', print_package.delivery_zip_code)
                    print('available: ', print_package.available)
                    print('delivery_deadline: ', print_package.delivery_deadline)
                    print('delivery_time: ', print_package.delivery_time)


            elif ":" in prompt:
                hour = int(prompt[0:prompt.find(":")])
                minutes = int(prompt[prompt.find(":")+1:])
                check_time = datetime(2020,5,29,hour,minutes,0)
                packages = self.get_package_details(check_time, self.truck1) + self.get_package_details(check_time, self.truck2)
                print("\n")
                package_details = {"Delivered":[], "Not Delivered":[], "Out For Delivery":[]}
                for package in packages:
                    dets = {'packageID':package.packageID,
                            'delivery_time':package.delivery_time.strftime("%H:%M:%S"),
                            'truck':package.truck}

                    if package.status == "Delivered":
                        dets.pop('truck')
                        package_details["Delivered"].append(dets)
                    elif package.status == "Not Delivered":
                        dets.pop('truck')
                        package_details["Not Delivered"].append(dets)
                    else:
                        package_details["Out For Delivery"].append(dets)

                for i,c in package_details.items():
                    print(i)
                    pprint(c)
                    print("\n")

            elif prompt == "q":
                print("\nThank you. Now exiting..\n")
                break

            else:
                package = self.lookup_package(packageID=int(prompt))
                print_package = deepcopy(package)
                print_package.status = "Delivered"
                print_package.delivery_time = print_package.delivery_time.strftime("%H:%M:%S")
                print_package.delivery_deadline = print_package.delivery_deadline.strftime("%H:%M:%S")
                print_package.available = print_package.available.strftime("%H:%M:%S")

                print('\n')
                print('package ID: ',  print_package.packageID)
                print('weight: ', print_package.weight)
                print('status: ', print_package.status)
                print('truck: ', print_package.truck)
                print('delivery address: ', print_package.delivery_address)
                print('address name: ', print_package.address_Name)
                print('city: ', print_package.delivery_city)
                print('zip: ', print_package.delivery_zip_code)
                print('available: ', print_package.available)
                print('delivery_deadline: ', print_package.delivery_deadline)
                print('delivery_time: ', print_package.delivery_time)
                print('\n')


            # except Exception as e:
            #     print(e)
            #     print("\n invalid input..\n")


    def get_package_details(self, check_time, truck):
        """
        Get package details for truck route at given check_time.
        Returns a list of package details as they were at the given time.
        """

        current_time = datetime(2020,5,29,8,0,0)
        packages = self.packages["Delivered"]
        passed_hub = False
        packages_at_time = []

        for i in range(1,len(truck.shortest_route)):

            location = truck.shortest_route[i]
            current_time =  current_time + timedelta(seconds=self.route_time([truck.shortest_route[i-1], location], truck.average_speed))
            # print("get_package", location, current_time)

            if current_time > check_time and not passed_hub:
                if location == "HUB":
                    passed_hub = True
                    continue

                else:
                    location_packages = self.get_packages(location, truck, package_search="Delivered")
                    for package in location_packages:
                        package.status = "Out For Delivery"
                        packages_at_time.append(package)

            elif current_time > check_time and passed_hub:
                # set not delivered
                location_packages = self.get_packages(location, truck, package_search="Delivered")
                for package in location_packages:
                    package.status = "Not Delivered"
                    packages_at_time.append(package)

            else:
                # set delivered
                location_packages = self.get_packages(location, truck, package_search="Delivered")
                for package in location_packages:
                    package.status = "Delivered"
                    packages_at_time.append(package)

        return packages_at_time



    def print_status(self):
        """
        Prints the status of packages at each delivery time throughout the day.
        """

        packages = self.packages["Delivered"]

        for packageID, package in packages.items():
            package.status = "Not Delivered"

        next_delivery_time = None
        while next_delivery_time != self.end_time:
            next_delivery_time = self.end_time
            for packageID, package in packages.items():
                if package.status == "Not Delivered" and package.delivery_time < next_delivery_time:
                    next_delivery_time = package.delivery_time

            for packageID, package in packages.items():
                if package.delivery_time <= next_delivery_time:
                    package.status = "Delivered"


            print(next_delivery_time)
            pprint([{packageID: package.status} for packageID, package in self.packages["Delivered"].items()])
            print("\n")



    def find_and_deliver(self, truck):
        """
        Updates information about packages being currently delivered. Gets delivery_time of next
        found route from get_truck_routes(). Sets truck's next delivery_time and moves truck to HUB
        if no next location is found or package limit is reached. Marks truck as done if at HUB and
        no packages are left to deliver.
        """

        if not truck.done:
            if truck.packages:
                for package in truck.currently_delivering:
                    if package.packageID in self.packages_with_deadlines:
                        self.packages_with_deadlines.remove(package.packageID)
                    truck.packages.remove(package)
            delivery_time = self.get_truck_routes(truck)
            if delivery_time:
                truck.time_of_next_delivered = delivery_time
            else:
                if self.left_to_deliver > 0 and truck.current_location != "HUB":
                    truck.shortest_route.append("HUB")
                    truck.time_left_hub = self.delivery_time
                    truck.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time([truck.current_location, "HUB"], truck.average_speed))
                    truck.current_location = "HUB"
                    truck.carried_without_going_to_hub = 0
                else:
                    if truck.current_location != "HUB":
                        truck.shortest_route.append("HUB")
                    print("truck done..")
                    truck.done = True


    def get_truck_routes(self, truck):
        """
        Find available locations, find truck route, and add_route if route found.
        Returns next delivery time or None if no route addition found.
        """

        if len(truck.packages) == 16:
            return None

        truck.locations = self.get_available_locations(truck)
        truck_route = self.find_route(truck, truck.locations, self.packaged_with_left)


        if truck_route:
            return self.add_route(truck, truck_route)
        else:
            return None


    def add_route(self, truck, location):
        """
        Updates truck data, adds packages/locations to route, returns projected delivery_time.
        If "HUB" in route add "HUB" distance and location to the route and reset packages
        carried away from hub. Mark packages' time of delivery.
        """

        new_location = location[0]
        hub_time = 0
        if "HUB" in location[0]:
            truck.time_left_hub = self.delivery_time
            new_location = new_location[1]
            truck.shortest_route.append("HUB")
            truck.carried_without_going_to_hub = 0
            hub_time = self.route_time([truck.current_location, "HUB"], truck.average_speed)

        truck.current_location = new_location
        truck.locations.remove(truck.current_location)
        truck.shortest_route.append(new_location)
        truck.route_time = self.route_time(truck.shortest_route, truck.average_speed)
        truck.currently_delivering_to = new_location

        location_packages = location[2]
        if hub_time:
            delivery_time = self.delivery_time + timedelta(seconds=hub_time + self.route_time(truck.shortest_route[-2:], truck.average_speed))
        else:
            delivery_time = self.delivery_time + timedelta(seconds=self.route_time(truck.shortest_route[-2:], truck.average_speed))

        for package in location_packages:

            package.truck = truck.truckNum
            package.status = "Delivered"
            self.packages["Not Delivered"].pop(package.packageID)
            self.packages["Delivered"][package.packageID] = package
            self.packages["Delivered"][package.packageID].delivery_time = delivery_time

            if package.packageID in self.packaged_with_left:
                for x, y in self.packages["Not Delivered"].items():
                    if x in self.packaged_with_left:
                        y.truck = truck.truckNum
                self.packaged_with_left.remove(package.packageID)
                self.packaged_with_truck = truck.truckNum

        truck.packages += location_packages
        truck.currently_delivering = location_packages
        truck.packages_delivered += len(location_packages)
        self.left_to_deliver -= len(location_packages)
        truck.carried_without_going_to_hub += len(location_packages)
        # # for package in location_packages:
        # #     if hub_time:
        # #         delivery_time = self.delivery_time + timedelta(seconds=hub_time + self.route_time(truck.shortest_route[-2:], truck.average_speed))
        # #     else:
        # #         delivery_time = self.delivery_time + timedelta(seconds=self.route_time(truck.shortest_route[-2:], truck.average_speed))
        #
        #     package.truck = truck.truckNum
        #     package.status = "Delivered"
        #     self.packages["Not Delivered"].pop(package.packageID)
        #     self.packages["Delivered"][package.packageID] = package
        #     self.packages["Delivered"][package.packageID].delivery_time = delivery_time

        return delivery_time

    def find_route(self, truck, locations, packaged_with_left=[]):
        """
        Find most efficient next location to add to route. Locations are weighted by
        package per distance (location_packages / route_distance). Adds "HUB" travel
        to the route if necessary.
        """

        shortest_route = [[truck.current_location], 0]
        location_visited = [truck.current_location]

        if locations and truck.carried_without_going_to_hub <= truck.max_packages:
            best_location = None
            best_ppd = 0
            truck_packages = []

            for location in locations:
                new_route = shortest_route[0] + [location]
                packages = self.get_packages(location, truck)

                need_to_go_to_hub_for_pickup = False
                for package in packages:
                    if truck.time_left_hub < package.available:
                        need_to_go_to_hub_for_pickup = True

                if (truck.truckNum == self.packaged_with_truck and truck.carried_without_going_to_hub + len(packaged_with_left) <= truck.max_packages) and need_to_go_to_hub_for_pickup == False:
                    route_distance = self.get_route_distance(new_route)
                    location_ppd = len(packages) / route_distance

                    if location_ppd > best_ppd:
                        best_ppd = location_ppd
                        best_location = location
                        truck_packages = packages

                elif truck.truckNum != self.packaged_with_truck and need_to_go_to_hub_for_pickup == False:
                    route_distance = self.get_route_distance(new_route)
                    location_ppd = len(packages) / route_distance

                    if location_ppd > best_ppd:
                        best_ppd = location_ppd
                        best_location = location
                        truck_packages = packages

                else:
                    if truck.truckNum == self.packaged_with_truck and len(packaged_with_left)>0:
                        continue
                    else:
                        route_distance = self.get_route_distance(new_route) + self.delivery_data.distances["HUB"][location]

                        location_ppd = len(packages) / route_distance

                        if location_ppd > best_ppd:
                            best_ppd = location_ppd
                            best_location = ["HUB", location]
                            truck_packages = packages


            return (best_location, best_ppd, truck_packages)


    def get_packages(self, location, truck, package_search="Not Delivered"):
        """
        Get packages for given location and truck. Returns list of package objects
        that have that location delivery address.
        """

        packages = []
        for package in self.packages[package_search].values():
            if package.address_Name == location:
                if package.truck == 0 or package.truck == truck.truckNum:
                    packages.append(package)

        return packages


    def get_available_locations(self, truck):
        """
        Get available locations to search for truck route.
        Prioritizes filling packaged_with packages.
        Returns a list of locations that are eligible for delivery for given truck.
        """

        available = []

        if truck.truckNum == self.packaged_with_truck:
            if truck.carried_without_going_to_hub + len(self.packaged_with_left) == truck.max_packages:
                available = [self.packages["Not Delivered"][packageID].address_Name for packageID in self.packaged_with_left]
                return available

        for package in self.packages["Not Delivered"].values():
            if(self.delivery_time + timedelta(seconds=self.route_time([truck.current_location, "HUB"], truck.average_speed))>=package.available):
                if int(package.truck) == 0 or int(package.truck) == int(truck.truckNum):
                    available.append(package.address_Name)

        return available


    def get_deadline_locations(self, deadline_packages):
        """
        Get all delivery locations for passed deadline_packages
        """
        return list(set(self.packages["Not Delivered"][packageID].address_Name for packageID in deadline_packages))


    def get_route_distance(self, route):
        """
        Get distance travelled of passed route based on data.Distances
        """

        distance = 0
        for i in range(len(route)-1):
            distance += self.delivery_data.distances[route[i]][route[i+1]]

        return distance


    def route_time(self, route, truck_speed):
        """
        Get time to complete route in seconds. Based of distance/truck speed
        """

        distance_miles = self.get_route_distance(route)
        distance_time = (distance_miles / truck_speed) * 60 * 60

        return distance_time



if __name__ == "__main__":
    SLC_Delivery_Data = Delivery_Data()
    truck1 = Truck(1)
    truck2 = Truck(2)
    dd = Delivery_Distribution(SLC_Delivery_Data, trucks=[truck1, truck2])
    for packageID, package_vars in SLC_Delivery_Data.packages.items():
        truck = 0
        available = "8:00"
        packaged_with = []

        if "Truck" in package_vars.keys():
            truck = package_vars["Truck"]
        if "Available" in package_vars.keys():
            available = package_vars["Available"]
        if "Packaged With" in package_vars.keys():
            packaged_with = package_vars["Packaged With"]

        dd.add_package(packageID,
                       package_vars["Address"],
                       SLC_Delivery_Data.address_to_place[package_vars["Address"]],
                       package_vars["Delivery_Deadline"],
                       package_vars["City"],
                       package_vars["Zip"],
                       package_vars["Weight"],
                       "Not Delivered",
                       truck=int(truck),
                       available=available,
                       packaged_with=packaged_with
                       )


    dd.set_truck_routes()


# need to pack truck 2 with all truck 2 packages
# group packages that have to be delivered
# prioritize delivery_deadlines
from data import packages, Distances
import time
from datetime import timedelta, time, datetime
from pprint import pprint
from copy import deepcopy

class Truck:
    """
    Function
    _________
        Represents a truck carrying packages and routes to travel

    Params
    _______
        __init__(self, truckNum)
            truckNum : the number of the truck. some packages require certain truckNum

        self.max_packages = 16  :  Maximum packages the truck can hold.
        self.average_speed = 18  :  Average speed the truck. Includes delivery time.
        self.truckNum = truckNum  :  The number of the truck. Some packages require certain truckNum.
        self.packages = []  :  Package objects that the truck is currently carrying.
        self.packages_delivered = 0  :  Number of packages the truck has delivered.
        self.carried_without_going_to_hub = 0  :  Number of packages "picked up" without restocking.
        self.locations = []  :  Locations to hold viable delivery points.
        self.current_location = "HUB"  :  Holds current location of the truck or next delivery location.
        self.shortest_route = ["HUB"]  :  Holds the route path generated by the Delivery_Distribution.find_route method.
        self.time_of_next_delivered = None  :  Time when next location pacakges will be delivered.
        self.currently_delivering_to = []  :  Holds next location step in route.

    Methods
    ________
        print_packages(self)  :  prints Package objects in self.packages
    """

    def __init__(self, truckNum):
        self.max_packages = 16
        self.average_speed = 18
        self.truckNum = truckNum
        self.packages = []
        self.packages_delivered = 0
        self.carried_without_going_to_hub = 0
        self.time_left_hub = None
        self.locations = []
        self.current_location = "HUB"
        self.shortest_route = ["HUB"]
        self.time_of_next_delivered = None
        self.currently_delivering_to = ""
        self.currently_delivering = []


    def print_packages(self):
        for package in self.packages:
            print(package)


class Package:
    """
    Function
    _________
        Represents a package. Holds package and delivery information.

    Params
    _______
        __init__(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[])

        self.packageID = packageID  :  Package ID
        self.delivery_address = delivery_address  :  Address it needs delivered to.
        self.address_Name = address_Name  :  Location name of address.
        self.delivery_deadline = delivery_deadline  :  Time package needs to be delivered by.
        self.delivery_city = delivery_city  :  City of address.
        self.delivery_zip_code = delivery_zip_code  :  Zip Code of address.
        self.weight = weight  :  Weight of the pacakge.
        self.status = status  :  Delivery Status of packages. "Delivered", "Out for delivery", "Not Delivered".
        self.truck = truck  :  Truck that is assigned to.
        self.available = available  :  Time that package is available for delivery.
        self.packaged_with = packaged_with  :  packageID's that have to be loaded at the same time.
        self.delivery_time = None  :  Time of delivery completion.

    Methods
    ________
        None
    """

    def __init__(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[]):
        self.packageID = packageID
        self.delivery_address = delivery_address
        self.address_Name = address_Name
        self.delivery_deadline = delivery_deadline
        self.delivery_city = delivery_city
        self.delivery_zip_code = delivery_zip_code
        self.weight = weight
        self.status = status
        self.truck = truck
        self.available = available
        self.packaged_with = packaged_with
        self.delivery_time = None

    def __repr__(self):
        return str({"packageID" : self.packageID,
                "delivery_address" : self.delivery_address,
                "address_Name" : self.address_Name,
                "delivery_deadline" : self.delivery_deadline,
                "delivery_city" : self.delivery_city,
                "delivery_zip_code" : self.delivery_zip_code,
                "weight" : self.weight,
                "status" : self.status,
                "truck" : self.truck,
                "available" : self.available,
                "packaged_with" : self.packaged_with
                })


class Delivery_Distribution:
    """
    Function
    _________
        Controls routing

    Params
    _______
        __init__(self, distances, trucks=[])

        self.packages = []  :  Packages in the system.
        self.left_to_deliver = 0  :  Packages without "Delivered" status.
        self.distances = distances  :  Distances object that holds distance information between locations.
        self.trucks = trucks  :  Array of Truck objects in the system.
        self.delivery_time = datetime(2020,5,29,8,0,0)  :  Time of day. Start 8:00
        self.end_time = self.delivery_time + timedelta(hours=9)  :  End of day.

    Methods
    ________
        add_package(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[])
            -- adds package to self.packages

        lookup_package(self, packageID=None, delivery_address=None, address_Name=None, delivery_deadline=None, delivery_city=None, delivery_zip_code=None, weight=None, status=None)
            -- lookup package

        lookup_status(self, packageID)
            -- lookup package status givin ID

        cycle_timer(self)
            -- simulates day

        get_truck_routes(self, truck)
            -- finds optimal route and adds for givin truck

        add_route(self, truck, location)
            -- adds route to truck, updates truck and package information

        find_route(self, truck, location_taken=None)
            -- find optimal route from available locations

        get_packages(self, location, truck)
            -- return valid packages for truck at location

        get_route_distance(self, route)
            -- return distance of passed route

        get_available_locations(self, truck)
            -- return available locations passed truck

        route_time(self, route)
            -- return time it takes to complete route

    """

    def __init__(self, distances, trucks=[]):
        self.packages = {"Delivered" : [], "Not Delivered" : []}
        self.left_to_deliver = 0
        self.distances = distances
        self.trucks = trucks
        self.delivery_time = datetime(2020,5,29,8,0,0)
        self.end_time = self.delivery_time + timedelta(hours=9)
        self.packaged_with_left = [13, 14, 15, 16, 19, 20]
        self.packaged_with_truck = 0
        self.packages_with_deadlines = []

    def add_package(self, packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=0, available="8:00", packaged_with=[]):
        if available == "8:00":
            available = self.delivery_time
        else:
            hours = int(available[:available.find(":")]) - 8
            mins = int(available[available.find(":")+1:])
            available = self.delivery_time + timedelta(hours=hours, minutes=mins)
        self.packages["Not Delivered"].append(Package(packageID, delivery_address, address_Name, delivery_deadline, delivery_city, delivery_zip_code, weight, status, truck=truck,
                                                      available=available, packaged_with=packaged_with))


    def lookup_package(self, packageID=None, delivery_address=None, address_Name=None, delivery_deadline=None, delivery_city=None, delivery_zip_code=None, weight=None, status=None):
        packages = []

        for package in self.packages["Delivered"] + self.packages["Not Delivered"]:
            if package.packageID == packageID:
                packages.append(package)
                return packages
            elif package.delivery_address == delivery_address:
                packages.append(package)
            elif package.address_Name == address_Name:
                packages.append(package)
            elif package.delivery_deadline == delivery_deadline:
                packages.append(package)
            elif package.delivery_city == delivery_city:
                packages.append(package)
            elif package.delivery_zip_code == delivery_zip_code:
                packages.append(package)
            elif package.weight == weight:
                packages.append(package)
            elif package.status == status:
                packages.append(package)
            else:
                continue

        return packages


    def lookup_status(self, packageID):
        return self.lookup_package(packageID=packageID)[0].status

    def get_packages_with_deadlines(self):
        self.packages_with_deadlines = []
        for package in self.packages["Not Delivered"]:
            if package.delivery_deadline != "EOD":
                self.packages_with_deadlines.append(package.packageID)


    def cycle_timer(self):
        self.get_packages_with_deadlines()
        self.left_to_deliver = len(self.packages["Not Delivered"])

        self.truck1 = self.trucks[0]
        self.truck2 = self.trucks[1]

        self.truck1.time_of_next_delivered = self.delivery_time
        self.truck2.time_of_next_delivered = self.delivery_time
        self.truck1.time_left_hub = self.delivery_time
        self.truck2.time_left_hub = self.delivery_time

        truck1_done = False
        truck2_done = False

        # print([x.address_Name for x in self.packages["Not Delivered"] if x.packageID in self.packaged_with_left])

        while self.delivery_time < self.end_time:
            # print(self.delivery_time, [x.delivery_deadline for x in self.packages["Not Delivered"] if x.packageID in self.packages_with_deadlines])
            # print(self.delivery_time, self.packages_with_deadlines)
            # print(self.delivery_time, self.truck1.time_of_next_delivered, self.truck2.time_of_next_delivered)
            # print(self.delivery_time, "  ", self.truck1.time_left_hub, " ", self.truck2.time_left_hub)
            if not truck1_done:
                if self.truck1.time_of_next_delivered <= self.delivery_time:
                    # print(self.get_route_distance(self.truck1.shortest_route))
                    # print(self.truck1.carried_without_going_to_hub)
                    # print(self.truck1.time_left_hub)
                    # print(self.delivery_time)
                    # print(self.truck1.shortest_route)
                    # print("\n")
                    if self.truck1.packages:
                        # packages_delivered = self.get_packages(self.truck1.currently_delivering_to, self.truck1)
                        for package in self.truck1.currently_delivering:
                            if package.packageID in self.packages_with_deadlines:
                                self.packages_with_deadlines.remove(package.packageID)
                            package.delivery_time = self.delivery_time
                            self.truck1.packages.remove(package)
                            package.truckNum = 0
                    delivery_time_1 = self.get_truck_routes(self.truck1)
                    if delivery_time_1:
                        self.truck1.time_of_next_delivered = delivery_time_1
                        # print(self.truck1.time_of_next_delivered, self.truck1.packages[-1])
                    else:
                        if self.left_to_deliver > 0 and self.truck1.current_location != "HUB":
                            self.truck1.shortest_route.append("HUB")
                            self.truck1.time_left_hub = self.delivery_time
                            self.truck1.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time([self.truck1.current_location, "HUB"]))
                            self.truck1.current_location = "HUB"
                            self.truck1.carried_without_going_to_hub = 0
                        else:
                            if self.truck1.current_location != "HUB":
                                self.truck1.shortest_route.append("HUB")
                            # print("truck1 done..")
                            truck1_done = True

            if not truck2_done:
                if self.truck2.time_of_next_delivered <= self.delivery_time:
                    # print(self.get_route_distance(self.truck2.shortest_route))
                    # print(self.truck2.carried_without_going_to_hub)
                    # print(self.truck2.time_left_hub)
                    # print(self.delivery_time)
                    # print(self.truck2.shortest_route)
                    # print("\n")
                    if self.truck2.packages:
                        # packages_delivered = self.get_packages(self.truck2.currently_delivering_to, self.truck2)
                        for package in self.truck2.currently_delivering:
                            if package.packageID in self.packages_with_deadlines:
                                self.packages_with_deadlines.remove(package.packageID)
                            package.delivery_time = self.delivery_time
                            self.truck2.packages.remove(package)
                            package.truckNum = 0
                    delivery_time_2 = self.get_truck_routes(self.truck2)
                    if delivery_time_2:
                        self.truck2.time_of_next_delivered = delivery_time_2
                        # print(truck1.time_of_next_delivered, self.truck2.packages[-1])
                    else:
                        if self.left_to_deliver > 0 and self.truck2.current_location != "HUB":
                            self.truck2.shortest_route.append("HUB")
                            self.truck2.time_left_hub = self.delivery_time
                            self.truck2.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time([self.truck2.current_location, "HUB"]))
                            self.truck2.current_location = "HUB"
                            self.truck2.carried_without_going_to_hub = 0
                        else:
                            if self.truck2.current_location != "HUB":
                                self.truck2.shortest_route.append("HUB")
                            # print("truck2 done..")
                            truck2_done = True

            if truck2_done and truck1_done:
                break
            else:
                self.delivery_time += timedelta(seconds=1)

        delivery_time = datetime(2020,5,29,8,0,0)

        pprint(self.packages)

        print("\ntruck1")
        print(self.get_route_distance(self.truck1.shortest_route))
        print(self.truck1.shortest_route)
        print(delivery_time + timedelta(seconds=self.truck1.route_time))
        print(f"truck1 packages_delivered: {self.truck1.packages_delivered}")

        print("\ntruck2")
        print(self.get_route_distance(self.truck2.shortest_route))
        print(self.truck2.shortest_route)
        print(delivery_time + timedelta(seconds=self.truck2.route_time))
        print(f"truck2 packages_delivered: {self.truck2.packages_delivered}")

        print(f"\ntotal distance: {self.get_route_distance(self.truck1.shortest_route) + self.get_route_distance(self.truck2.shortest_route)}")


    def get_truck_routes(self, truck):

        if len(truck.packages) == 16:
            return None

        truck.locations = self.get_available_locations(truck)

        # print(truck.truckNum, truck.carried_without_going_to_hub)
        # pprint(truck.locations)

        truck_route = self.find_route(truck, truck.locations, self.packaged_with_left)


        if truck_route:
            # find if deadlines can be met with truck_route. cycle timer with only deadline_packages
            # self.get_packages_with_deadlines()
            # deadline_packages = self.packages_with_deadlines[:]
            #
            # self.deadlines_possible(truck.truckNum, deadline_packages, truck_route)

            return self.add_route(truck, truck_route)

        else:
            return None
    #
    # def deadlines_possible(self, current_truck, deadline_packages, truck_route):
    #     truck1 = deepcopy(self.truck1)
    #     truck2 = deepcopy(self.truck2)
    #
    #     if current_truck == 1:
    #         if "HUB" in truck_route[0]:
    #             truck1.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time(truck_route[0]))
    #             truck1.current_location = truck_route[0][-1]
    #         else:
    #             truck1.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time([truck1.current_location, truck_route[0]]))
    #             truck1.current_location = truck_route[0]
    #
    #         truck1.carried_without_going_to_hub += len(truck_route[2])
    #
    #     elif current_truck == 2:
    #         if "HUB" in truck_route[0]:
    #             truck2.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time(truck_route[0]))
    #             truck2.current_location = truck_route[0][-1]
    #
    #         else:
    #             truck2.time_of_next_delivered = self.delivery_time + timedelta(seconds = self.route_time([truck2.current_location, truck_route[0]]))
    #             truck2.current_location = truck_route[0]
    #
    #         truck2.carried_without_going_to_hub += len(truck_route[2])
    #
    #
    #     # remove all packaged with
    #     deadline_packages = [x for x in deadline_packages if x not in self.packaged_with_left]
    #
    #     if not deadline_packages:
    #         return True
    #     print(deadline_packages)
    #
    #     deadline_locations = self.get_deadline_locations(deadline_packages)
    #
    #     if truck1.current_location in deadline_locations:
    #         deadline_locations.remove(truck1.current_location)
    #         for package in self.get_packages(truck1.current_location, truck1):
    #             if package.packageID in deadline_packages:
    #                 deadline_packages.remove(package.packageID)
    #
    #     elif truck2.current_location in deadline_locations:
    #         deadline_locations.remove(truck2.current_location)
    #         for package in self.get_packages(truck2.current_location, truck2):
    #             if package.packageID in deadline_packages:
    #                 deadline_packages.remove(package.packageID)
    #
    #     print(deadline_locations)
    #     print("\n")
    #
    #
    #     packaged_with_check = False
    #     while deadline_packages:
    #
    #         # print("cycle")
    #         # print(f"deadline_packages: {deadline_packages}")
    #         # print(f"deadline_locations: {deadline_locations}")
    #         print("\n")
    #         print(truck1.shortest_route)
    #         print(truck1.time_of_next_delivered)
    #         print(truck2.shortest_route)
    #         print(truck2.time_of_next_delivered)
    #
    #         # print(truck1.time_of_next_delivered, truck2.time_of_next_delivered)
    #
    #
    #         # take out not available
    #         search_locations = []
    #
    #
    #
    #
    #         if truck1.carried_without_going_to_hub + len(self.packaged_with_left) > truck1.max_packages:
    #             print("overload")
    #             packaged_with_check = True
    #             truck1.carried_without_going_to_hub = 0
    #             packaged_with_left_route = [x.address_Name for x in self.packages["Not Delivered"] if x.packageID in self.packaged_with_left]
    #             new_route = [truck1.current_location] + packaged_with_left_route + ["HUB"]
    #             truck1.shortest_route += new_route
    #             truck1.time_of_next_delivered += timedelta(seconds = self.route_time(new_route))
    #             truck1.current_location = "HUB"
    #
    #
    #         elif truck1.time_of_next_delivered < truck2.time_of_next_delivered:
    #             if not packaged_with_check:
    #                 print(truck1.carried_without_going_to_hub + len(self.packaged_with_left))
    #                 route = self.find_route(truck1, deadline_locations, packaged_with_left = self.packaged_with_left)
    #
    #                 if not route:
    #                     route = self.find_route(truck2, deadline_locations)
    #                     deadline_locations, deadline_packages = self.deadline_cycle(truck2, route, deadline_locations, deadline_packages)
    #
    #                 else:
    #                     deadline_locations, deadline_packages = self.deadline_cycle(truck1, route, deadline_locations, deadline_packages)
    #             else:
    #                 route = self.find_route(truck1, deadline_locations)
    #
    #                 if not route:
    #                     route = self.find_route(truck2, deadline_locations)
    #                     deadline_locations, deadline_packages = self.deadline_cycle(truck2, route, deadline_locations, deadline_packages)
    #
    #                 else:
    #                     deadline_locations, deadline_packages = self.deadline_cycle(truck1, route, deadline_locations, deadline_packages)
    #
    #         else:
    #             route = self.find_route(truck2, deadline_locations)
    #             print(route)
    #             if not route:
    #                 route = self.find_route(truck1, deadline_locations)
    #                 deadline_locations, deadline_packages = self.deadline_cycle(truck1, route, deadline_locations, deadline_packages)
    #
    #
    #             else:
    #                 # print(route)
    #                 # print(self.lookup_package(packageID=13))
    #                 deadline_locations, deadline_packages = self.deadline_cycle(truck2, route, deadline_locations, deadline_packages)
    #
    #     print(truck1.shortest_route)
    #     print(truck1.time_of_next_delivered)
    #     print(truck2.shortest_route)
    #     print(truck2.time_of_next_delivered)
    #     print("\n")
    #
    # def deadline_cycle(self, truck, route, deadline_locations, deadline_packages):
    #
    #     if "HUB" in route[0]:
    #         truck.shortest_route += route[0]
    #         truck.carried_without_going_to_hub = 0
    #         hub_time = self.route_time([truck.current_location, "HUB"])
    #         truck.time_left_hub = truck.time_of_next_delivered + timedelta(seconds=hub_time)
    #
    #         truck.current_location = route[0][1]
    #         deadline_locations.remove(truck.current_location)
    #
    #         for package in route[2]:
    #             if package.packageID in deadline_packages:
    #                 deadline_packages.remove(package.packageID)
    #
    #         truck.carried_without_going_to_hub += len(route[2])
    #         truck.time_of_next_delivered += timedelta(seconds=hub_time + self.route_time(truck.shortest_route[-2:]))
    #
    #     else:
    #         truck.shortest_route.append(route[0])
    #
    #         truck.current_location = route[0]
    #         deadline_locations.remove(truck.current_location)
    #
    #         for package in route[2]:
    #             if package.packageID in deadline_packages:
    #                 deadline_packages.remove(package.packageID)
    #
    #         truck.carried_without_going_to_hub += len(route[2])
    #         truck.time_of_next_delivered += timedelta(seconds = self.route_time(truck.shortest_route[-2:]))
    #
    #     return deadline_locations, deadline_packages


    def add_route(self, truck, location):

        new_location = location[0]
        hub_time = 0
        if "HUB" in location[0]:
            truck.time_left_hub = self.delivery_time
            new_location = new_location[1]
            truck.shortest_route.append("HUB")
            truck.carried_without_going_to_hub = 0
            hub_time = self.route_time([truck.current_location, "HUB"])

        truck.current_location = new_location
        truck.locations.remove(truck.current_location)
        truck.shortest_route.append(new_location)
        truck.route_time = self.route_time(truck.shortest_route)
        truck.currently_delivering_to = new_location

        location_packages = location[2]
        for package in location_packages:
            if package.packageID in self.packaged_with_left:
                for x in self.packages["Not Delivered"]:
                    if x.packageID in self.packaged_with_left:
                        x.truck = truck.truckNum
                # print(truck.truckNum, package.address_Name)
                self.packaged_with_left.remove(package.packageID)
                self.packaged_with_truck = truck.truckNum

        truck.packages += location_packages
        truck.currently_delivering = location_packages
        truck.packages_delivered += len(location_packages)
        self.left_to_deliver -= len(location_packages)
        truck.carried_without_going_to_hub += len(location_packages)
        for package in location_packages:
            package.truck = truck.truckNum
            package.status = "Delivered"
            self.packages["Not Delivered"].remove(package)
            self.packages["Delivered"].append(package)

            if hub_time:
                delivery_time = self.delivery_time + timedelta(seconds=hub_time + self.route_time(truck.shortest_route[-2:]))
            else:
                delivery_time = self.delivery_time + timedelta(seconds=self.route_time(truck.shortest_route[-2:]))

        return delivery_time

    def find_route(self, truck, locations, packaged_with_left=[]):

        shortest_route = [[truck.current_location], 0]
        location_visited = [truck.current_location]

        if locations and truck.carried_without_going_to_hub <= truck.max_packages:
            best_location = None
            best_ppd = 0
            truck_packages = []

            for location in locations:
                new_route = shortest_route[0] + [location]
                packages = self.get_packages(location, truck)

                need_to_go_to_hub_for_pickup = False
                for package in packages:
                    if truck.time_left_hub < package.available:
                        need_to_go_to_hub_for_pickup = True


                # print(truck.carried_without_going_to_hub + len(packaged_with_left), need_to_go_to_hub_for_pickup)
                if (truck.truckNum == self.packaged_with_truck and truck.carried_without_going_to_hub + len(packaged_with_left) <= truck.max_packages) and need_to_go_to_hub_for_pickup == False:
                    route_distance = self.get_route_distance(new_route)
                    location_ppd = len(packages) / route_distance

                    if location_ppd > best_ppd:
                        best_ppd = location_ppd
                        best_location = location
                        truck_packages = packages

                elif truck.truckNum != self.packaged_with_truck and need_to_go_to_hub_for_pickup == False:
                    route_distance = self.get_route_distance(new_route)
                    location_ppd = len(packages) / route_distance

                    if location_ppd > best_ppd:
                        best_ppd = location_ppd
                        best_location = location
                        truck_packages = packages

                else:
                    if truck.truckNum == self.packaged_with_truck and len(packaged_with_left)>0:
                        continue
                    else:
                        route_distance = self.get_route_distance(new_route) + self.distances.distances["HUB"][location]

                        location_ppd = len(packages) / route_distance

                        if location_ppd > best_ppd:
                            best_ppd = location_ppd
                            best_location = ["HUB", location]
                            truck_packages = packages


            return (best_location, best_ppd, truck_packages)


    def get_packages(self, location, truck):
        packages = []
        for package in self.packages["Not Delivered"]:
            if package.address_Name == location:
                if package.truck == 0 or package.truck == truck.truckNum:

                    packages.append(package)

        return packages


    def get_available_locations(self, truck):

        available = []

        if truck.truckNum == self.packaged_with_truck:
            if truck.carried_without_going_to_hub + len(self.packaged_with_left) == truck.max_packages:
                available = [package.address_Name for package in self.packages["Not Delivered"] if package.packageID in self.packaged_with_left]
                return available

        for package in self.packages["Not Delivered"]:
            if(self.delivery_time + timedelta(seconds=self.route_time([truck.current_location, "HUB"]))>=package.available):
                if int(package.truck) == 0 or int(package.truck) == int(truck.truckNum):
                    available.append(package.address_Name)

        return available


    def get_deadline_locations(self, deadline_packages):
        return list(set(package.address_Name for package in self.packages["Not Delivered"] if package.packageID in deadline_packages))


    def get_route_distance(self, route):
        distance = 0
        for i in range(len(route)-1):
            distance += self.distances.distances[route[i]][route[i+1]]

        return distance


    def route_time(self, route):
        distance_miles = self.get_route_distance(route)
        distance_time = (distance_miles / 18) * 60 * 60

        return distance_time



if __name__ == "__main__":
    Distances = Distances()
    truck1 = Truck(1)
    truck2 = Truck(2)
    dd = Delivery_Distribution(Distances, trucks=[truck1, truck2])
    for packageID, package_vars in packages.items():
        truck = 0
        available = "8:00"
        packaged_with = []

        if "Truck" in package_vars.keys():
            truck = package_vars["Truck"]
        if "Available" in package_vars.keys():
            available = package_vars["Available"]
        if "Packaged With" in package_vars.keys():
            packaged_with = package_vars["Packaged With"]

        dd.add_package(packageID,
                       package_vars["Address"],
                       Distances.address_to_place[package_vars["Address"]],
                       package_vars["Delivery_Deadline"],
                       package_vars["City"],
                       package_vars["Zip"],
                       package_vars["Weight"],
                       "Not Delivered",
                       truck=int(truck),
                       available=available,
                       packaged_with=packaged_with
                       )


    dd.cycle_timer()
